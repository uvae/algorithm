# Matrix Chain Multiplication (행렬 체인 곱셈)

## 문제 설명

연속된 행렬들의 곱셈을 수행할 때, 최소의 스칼라 곱셈 연산으로 계산하는 순서를 찾는 문제입니다.

### 입력

- n개의 행렬 차원을 나타내는 배열 dimensions[0..n]
- dimensions[i-1] × dimensions[i] = i번째 행렬의 차원

### 출력

- 최소 연산 횟수
- 최적의 괄호 배치

## 알고리즘

### 동적 프로그래밍 접근

1. 부분 문제 정의
   - m[i,j]: i번째부터 j번째 행렬까지의 최소 연산 횟수
   - s[i,j]: i번째부터 j번째 행렬을 곱할 때의 최적 분할 지점
2. 점화식
   - m[i,j] = min(m[i,k] + m[k+1,j] + p[i-1]p[k]p[j])
   - i ≤ k < j
3. 베이스 케이스
   - m[i,i] = 0

### 구현 특징

- 상향식(Bottom-up) 방식
- 부분 문제의 최적해 저장
- 최적 부분 구조 활용

## 시각화 기능

### DP 테이블 시각화

- m 테이블: 최소 연산 횟수
- s 테이블: 최적 분할 지점
- 히트맵으로 값 표현
- 현재 계산 중인 셀 강조

## 사용 방법

### 기본 실행

# Matrix Chain Multiplication (행렬 체인 곱셈)

## 문제 설명

연속된 행렬들의 곱셈을 수행할 때, 최소의 스칼라 곱셈 연산으로 계산하는 순서를 찾는 문제입니다.

### 입력

- n개의 행렬 차원을 나타내는 배열 dimensions[0..n]
- dimensions[i-1] × dimensions[i] = i번째 행렬의 차원

### 출력

- 최소 연산 횟수
- 최적의 괄호 배치

## 알고리즘

### 동적 프로그래밍 접근

1. 부분 문제 정의
   - m[i,j]: i번째부터 j번째 행렬까지의 최소 연산 횟수
   - s[i,j]: i번째부터 j번째 행렬을 곱할 때의 최적 분할 지점
2. 점화식
   - m[i,j] = min(m[i,k] + m[k+1,j] + p[i-1]p[k]p[j])
   - i ≤ k < j
3. 베이스 케이스
   - m[i,i] = 0

### 구현 특징

- 상향식(Bottom-up) 방식
- 부분 문제의 최적해 저장
- 최적 부분 구조 활용

## 시각화 기능

### DP 테이블 시각화

- m 테이블: 최소 연산 횟수
- s 테이블: 최적 분할 지점
- 히트맵으로 값 표현
- 현재 계산 중인 셀 강조
  